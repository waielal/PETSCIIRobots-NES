.include "VAR.asm"
.include "DATA.asm"
.include "CODE.INIT.asm"
.include "CODE.SPRITES.asm"
.include "CODE.PLOT.asm"

.include "PPU_TRANSFER.asm"
.include "NMI.NTSC.asm"
.include "IRQ.NTSC.asm"
.include "NMI.PAL.asm"
.include "IRQ.PAL.asm"

.INCLUDE "CODE.BGTASKS.ASM"
.INCLUDE "CODE.BGTASKS2.ASM"
.INCLUDE "CODE.MAP.ASM"
.INCLUDE "CODE.PAUSE.ASM"
.INCLUDE "CODE.GAMEOVER.ASM"

.INCLUDE "CODE.ELEVATOR.ASM"
.INCLUDE "CODE.INFO.ASM"

.segment BANK(BK_MAIN_CODE)
;This is the routine that runs every 50/60 seconds from the IRQ.
;BG_TIMER is always set to 1 every cycle, after which the main
;program will reset it to 0 when it is done with it's work for
;that cycle.  GP_TIMER is a count-down to zero and then stays
;there.
.proc RUNIRQ_NTSC
	; skip every 6th frame so that the game
	; always updated 50 times a second
	INC	COUNTER
	INC	FRAMES
	LDA	FRAMES
	CMP	#6
	BNE	RUNIRQ_PAL
	LDA	#0
	STA	FRAMES
	RTS
.endproc

.proc RUNIRQ_PAL
	JSR	UPDATE_GAME_CLOCK
	JSR	ANIMATE_WATER
	
	LDX	#0
@loop:	LDA	GAME_TIMER,X
	BEQ	@skip
	DEC	GAME_TIMER,X
@skip:	INX
	CPX	#GAME_TIMER_NUM
	BNE	@loop

	LDA	EMP_TIMER
	CMP	#1
	BNE	:+
	SET_GAME_BG_PALETTE  GAME_BG_PALETTE_NORMAL
:	RTS
.endproc


.proc UPDATE_GAME_CLOCK
	BBC	GAME_FLAG, F_CLOCK_ACTIVE, @end
	INC	CYCLES
	LDA	CYCLES
	CMP	#50
	BNE	@end
	LDA	#0
	STA	CYCLES
	INC	SECONDS
	LDA	SECONDS
	CMP	#60
	BNE	@end
	LDA	#0
	STA	SECONDS
	INC	MINUTES
	LDA	MINUTES
	CMP	#60
	BNE	@end
	LDA	#0
	STA	MINUTES
	INC	HOURS
@end:	RTS
.endproc


.proc INIT_GAME
	PPU_DISABLE

	SET_IRQ_ROUTINE  DUMMY_ROUTINE
	SET_NMI_ROUTINE  DUMMY_ROUTINE
	WAIT_NMI
	
	ZP_CLEAR   $20
	; RAM_CLEAR

	; save pointer to custom message
	LDA	PTR_0_H
	PHA
	LDA	PTR_0_L
	PHA

	MMC3_BANK_SELECT  MMC3_CHR_0, #TS_GAME_FIELD+0
	MMC3_BANK_SELECT  MMC3_CHR_1, #TS_GAME_FIELD+2
	MMC3_BANK_SELECT  MMC3_CHR_2, #TS_GAME_SPRITES+0
	MMC3_BANK_SELECT  MMC3_CHR_3, #TS_GAME_SPRITES+1
	MMC3_BANK_SELECT  MMC3_CHR_4, #TS_GAME_SPRITES+2
	MMC3_BANK_SELECT  MMC3_CHR_5, #TS_GAME_SPRITES+3

	MMC3_BANK_SELECT  MMC3_PRG_0, #BK_GENERAL, SAVED_PRG_0
	JSR	LOAD_MAP

	MMC3_BANK_SELECT  MMC3_PRG_1, #BK_GAME_CODE, SAVED_PRG_1

	BIT	PPUSTATUS
	JSR	INIT_GAME_PALETTE

	SET_GAME_BG_PALETTE  GAME_BG_PALETTE_NORMAL

	OAM_HIDE_ALL_SPRITE

	JSR	SOUND_SYSTEM_MUSIC_RESUME

	JSR	INIT_GAME_SCREEN
	JSR	INIT_PLAYER
	JSR	INIT_PLAYER_HEALTH
	JSR	INIT_ITEMS
	JSR	INIT_WEAPONS
	JSR	INIT_KEYS
	
	JSR	INIT_INFO
	JSR	INIT_DIFF_LEVEL
	JSR	INIT_CLOCK
	JSR	INIT_UNIT_TIMERS
	JSR	INIT_GAME_VARS

	LDA	#0
	STA	SCREEN_SHAKE
	LDA	#12
	STA	UNIT_TILE ; Player looks to the right
	LDA	#1
	STA	UNIT_TYPE
	LDA	#30
	STA	KEY_TIMER
	LDA	#4
	STA	SCROLL_X

	LDA	#' '
	LDX	#0
@loop1:	STA	SCR_BUFFER+0*$100,X
	STA	SCR_BUFFER+1*$100,X
	INX
	BNE	@loop1
	LDX	#160
@loop2:	DEX
	STA	SCR_BUFFER+2*$100,X
	BNE	@loop2


	JSR	ANIMATE_PLAYER
	JSR	CALCULATE_AND_REDRAW	
	JSR	CLEAR_INFO

	JSR	DISPLAY_PLAYER_HEALTH
	JSR	DISPLAY_KEYS
	JSR	DISPLAY_WEAPON
	JSR	DISPLAY_ITEM

	LDA	TV_SYSTEM
	CMP	#1
	BEQ	@pal
@ntsc:
	SET_IRQ_ROUTINE  IRQ_GAME_NTSC
	MMC3_IRQ_DISABLE
	CLI
	SET_NMI_ROUTINE  NMI_GAME_NTSC
	JMP	@post_init
@pal:
	SET_IRQ_ROUTINE  IRQ_GAME_PAL
	MMC3_IRQ_DISABLE
	CLI
	SET_NMI_ROUTINE  NMI_GAME_PAL


@post_init:
	SETB	GAME_FLAG, F_TRANSFER_FIELD
	JSR	GAME_NEXT_FRAME
	SETB	GAME_FLAG, F_TRANSFER_FIELD
	JSR	GAME_NEXT_FRAME
	SETB	GAME_FLAG, F_TRANSFER_FIELD
	JSR	GAME_NEXT_FRAME

	; restore pointer to custom message
	PLA
	STA	PTR_0_L
	PLA
	STA	PTR_0_H
	BNE	:+
	; if its empty print default message
	LDADDR	PTR_0, MSG_WELCOME
:	JSR	PRINT_INFO

	JMP	MAIN_GAME_LOOP
.endproc


.proc MAIN_GAME_LOOP
	JSR	GAME_NEXT_FRAME
	JSR	READ_JOYPAD
	LDA	UNIT_TYPE
	CMP	#1	;Is player unit alive
	BEQ	:+
	JMP	GAME_OVER
:
	;check keytimer for repeat time.
	LDA	KEY_TIMER
	CMP	#0
	BEQ	:+
	JMP	@SC40
:
	;first we start with the 4 directional buttons.
	JOYPAD_BR_IF_L_NOT_HELD  @SC10
	JMP	MOVE_LEFT
@SC10:	JOYPAD_BR_IF_R_NOT_HELD  @SC20
	JMP	MOVE_RIGHT
@SC20:	JOYPAD_BR_IF_U_NOT_HELD  @SC30
	JMP	MOVE_UP
@SC30:	JOYPAD_BR_IF_D_NOT_HELD  @SC35
	JMP	MOVE_DOWN
@SC35:	CLRB	GAME_FLAG, F_KEY_FAST
@SC40:	
	;Now check for non-repeating buttons
	; deside whether to use nes or snes controls
	JOYPAD_BR_IF_IS_SNES  GAME_INPUT_SNES, GAME_INPUT_NES
.endproc
	
.proc GAME_INPUT_NES
	JOYPAD_BR_IF_NES_A_NOT_PRESSED  @SC50
	LDA	UNIT_TILE
	LSR
	LSR
	JMP	@SC51
@SC50:	JOYPAD_BR_IF_NES_B_NOT_PRESSED  @SC70
	LDA	UNIT_TILE
	LSR
	LSR
	EOR	#$02	; flip direction
@SC51:	CMP	#PLAYER_DIR_D
	BEQ	@SC60
	CMP	#PLAYER_DIR_L
	BEQ	@SC61
	CMP	#PLAYER_DIR_U
	BEQ	@SC62
	CMP	#PLAYER_DIR_R
	BEQ	@SC63
@SC60:	JSR	FIRE_DOWN
	JMP	MAIN_GAME_LOOP
@SC61:	JSR	FIRE_LEFT
	JMP	MAIN_GAME_LOOP
@SC62:	JSR	FIRE_UP
	JMP	MAIN_GAME_LOOP
@SC63:	JSR	FIRE_RIGHT
	JMP	MAIN_GAME_LOOP

@SC70:	JOYPAD_BR_IF_SELECT_NOT_PRESSED  @SC80
	LDA	#12
	STA	GP_TIMER
	JMP	NES_SELECT_DOWN
@SC80:	JOYPAD_BR_IF_START_NOT_PRESSED  @SC90
	LDA	#10
	STA	GP_TIMER
	JMP	NES_START_DOWN
@SC90:	
	JMP	MAIN_GAME_LOOP
.endproc

.proc GAME_INPUT_SNES
	JOYPAD_BR_IF_SNES_Y_NOT_PRESSED  @SN45
	JSR	FIRE_LEFT
@SN45:	JOYPAD_BR_IF_SNES_A_NOT_PRESSED  @SN50
	JSR	FIRE_RIGHT
@SN50:	JOYPAD_BR_IF_SNES_X_NOT_PRESSED  @SN55
	JSR	FIRE_UP
@SN55:	JOYPAD_BR_IF_SNES_B_NOT_PRESSED  @SN60
	JSR	FIRE_DOWN
@SN60:	JOYPAD_BR_IF_SELECT_NOT_PRESSED  @SN65
	LDA	#10
	STA	GP_TIMER
	JMP	SNES_SELECT_DOWN
@SN65:	JOYPAD_BR_IF_SNES_R_NOT_PRESSED  @SN70
	JSR	MOVE_OBJECT
	LDA	#15
	STA	KEY_TIMER
	JMP	MAIN_GAME_LOOP
@SN70:	JOYPAD_BR_IF_SNES_L_NOT_PRESSED  @SN80
	JSR	SEARCH_OBJECT
	LDA	#15
	STA	KEY_TIMER
	JMP	MAIN_GAME_LOOP
@SN80:	JOYPAD_BR_IF_START_NOT_PRESSED  @SN90
	JSR	USE_ITEM
	LDA	#15
	STA	KEY_TIMER
	JMP	MAIN_GAME_LOOP
@SN90:	
	JMP	MAIN_GAME_LOOP
.endproc

.proc NES_SELECT_DOWN
	JSR	GAME_NEXT_FRAME
	JSR	READ_JOYPAD
	LDA	UNIT_TYPE
	CMP	#1	;Is player unit alive
	BEQ	@SLD01
	JMP	GAME_OVER
@SLD01:
	LDA	GP_TIMER	; while time != 0
	BEQ	@SLD02
	JOYPAD_BR_IF_SELECT_HELD  NES_SELECT_DOWN
	JMP	PAUSE_GAME
	
@SLD02:
	; LDADDR	PTR_0, MSG_ROTATE_M
	; JSR	PRINT_INFO
	; LDADDR	PTR_0, MSG_SELECT
	; JSR	PRINT_INFO
	; JSR	SCROLL_INFO
	JSR	CLEAR_INFO
	LDADDR	PTR_0, MSG_ROTATE
	JSR	PRINT_INFO
	LDADDR	PTR_0, MSG_ROTATE
	JSR	PRINT_INFO
	LDADDR	PTR_0, MSG_MAP
	JSR	PRINT_INFO

@SLD_LOOP:
	JSR	GAME_NEXT_FRAME
	JSR	READ_JOYPAD
	LDA	UNIT_TYPE
	CMP	#1	;Is player unit alive
	BEQ	@SLD03
	JMP	GAME_OVER
@SLD03:
	JOYPAD_BR_IF_SELECT_HELD  @SLD05
	JSR	CLEAR_INFO
	LDA	#15
	STA	KEY_TIMER
	JMP	MAIN_GAME_LOOP
@SLD05:
	JOYPAD_BR_IF_L_NOT_PRESSED  @SLD10
	LDA	#(PLAYER_DIR_L << 2)
	JMP	@SLD40
@SLD10:
	JOYPAD_BR_IF_R_NOT_PRESSED  @SLD20
	LDA	#(PLAYER_DIR_R << 2)
	JMP	@SLD40
@SLD20:
	JOYPAD_BR_IF_U_NOT_PRESSED  @SLD30
	LDA	#(PLAYER_DIR_U << 2)
	JMP	@SLD40
@SLD30:
	JOYPAD_BR_IF_D_NOT_PRESSED  @SLD50
	LDA	#(PLAYER_DIR_D << 2)
	JMP	@SLD40
@SLD40:
	STA	UNIT_TILE
	LDA	#0
	STA	GP_TIMER
	JSR	ANIMATE_PLAYER
	JSR	CALCULATE_AND_REDRAW
	JMP	@SLD_LOOP
@SLD50:
	JOYPAD_BR_IF_START_NOT_PRESSED  @SLD55
	JMP	SHOW_GAME_MAP
@SLD55:
	JOYPAD_BR_IF_NES_B_NOT_PRESSED  @SLD60
	JMP	DBG_SELECT_DOWN
@SLD60:
	JMP	@SLD_LOOP
.endproc


.proc NES_START_DOWN
	JSR	GAME_NEXT_FRAME_FREEZED
	JSR	READ_JOYPAD
@SRD01:
	LDA	GP_TIMER	; while time != 0
	BEQ	@SRD02
	JOYPAD_BR_IF_START_HELD  NES_START_DOWN
	JSR	USE_ITEM
	LDA	#15
	STA	KEY_TIMER
	JMP	MAIN_GAME_LOOP
@SRD02:
	SET_GAME_BG_PALETTE  GAME_BG_PALETTE_DARKEN
	JSR	DISPLAY_HELPER_ICONS_NES
@SRD_LOOP:
	JSR	GAME_NEXT_FRAME_FREEZED
	JSR	READ_JOYPAD

	JOYPAD_BR_IF_START_HELD  @SRD05
	SET_GAME_BG_PALETTE  GAME_BG_PALETTE_NORMAL
	JSR	HIDE_HELPER_ICONS
	JMP	MAIN_GAME_LOOP

@SRD05:
	JOYPAD_BR_IF_D_NOT_PRESSED  @SRD10
	SET_GAME_BG_PALETTE  GAME_BG_PALETTE_NORMAL
	JSR	HIDE_HELPER_ICONS
	JSR	SEARCH_OBJECT
	LDA	#15
	STA	KEY_TIMER
	JMP	MAIN_GAME_LOOP
@SRD10:
	JOYPAD_BR_IF_R_NOT_PRESSED  @SRD20
	JSR	CYCLE_ITEM
	LDA	#15
	STA	KEY_TIMER
	LDA	#0
	STA	GP_TIMER
	JMP	@SRD50
@SRD20:
	JOYPAD_BR_IF_L_NOT_PRESSED  @SRD30
	JSR	CYCLE_WEAPON
	LDA	#15
	STA	KEY_TIMER
	LDA	#0
	STA	GP_TIMER
	JMP	@SRD50
@SRD30:
	JOYPAD_BR_IF_U_NOT_PRESSED  @SRD40
	SET_GAME_BG_PALETTE  GAME_BG_PALETTE_NORMAL
	JSR	HIDE_HELPER_ICONS
	JSR	MOVE_OBJECT
	LDA	#15
	STA	KEY_TIMER
	JMP	MAIN_GAME_LOOP
@SRD40:
; 	JOYPAD_BR_IF_SELECT_NOT_PRESSED  @SRD50
; 	JMP	SHOW_GAME_MAP
@SRD50:
	LDA	#15
	STA	KEY_TIMER
	JMP	@SRD_LOOP
.endproc


.proc SNES_SELECT_DOWN
	JSR	GAME_NEXT_FRAME_FREEZED
	JSR	READ_JOYPAD
@SRD01:
	LDA	GP_TIMER	; while time != 0
	BEQ	@SLD02
	JOYPAD_BR_IF_SELECT_HELD  SNES_SELECT_DOWN
	JMP	PAUSE_GAME

@SLD02:
	SET_GAME_BG_PALETTE  GAME_BG_PALETTE_DARKEN
	JSR	DISPLAY_HELPER_ICONS_SNES
@SLD_LOOP:
	JSR	GAME_NEXT_FRAME_FREEZED
	JSR	READ_JOYPAD

	JOYPAD_BR_IF_SELECT_HELD  @SLD10
	SET_GAME_BG_PALETTE  GAME_BG_PALETTE_NORMAL
	JSR	HIDE_HELPER_ICONS
	JMP	MAIN_GAME_LOOP

@SLD10:	JOYPAD_BR_IF_SNES_R_NOT_PRESSED  @SLD20
	JSR	CYCLE_ITEM
	JMP	@SLD99
	
@SLD20:	JOYPAD_BR_IF_R_NOT_PRESSED  @SLD30
	JSR	CYCLE_ITEM
	JMP	@SLD99

@SLD30:	JOYPAD_BR_IF_SNES_L_NOT_PRESSED  @SLD40
	JSR	CYCLE_WEAPON
	JMP	@SLD99

@SLD40:	JOYPAD_BR_IF_L_NOT_PRESSED  @SLD50
	JSR	CYCLE_WEAPON
	JMP	@SLD99

@SLD50:	JOYPAD_BR_IF_D_NOT_PRESSED  @SLD60
	JSR	HIDE_HELPER_ICONS
	JMP	SHOW_GAME_MAP

@SLD60:	JOYPAD_BR_IF_START_NOT_PRESSED  @SLD70
	JSR	HIDE_HELPER_ICONS
	JMP	SHOW_GAME_MAP
	
@SLD70:	JOYPAD_BR_IF_SNES_B_NOT_PRESSED  @SLD99
	JSR	HIDE_HELPER_ICONS
	JMP	DBG_SELECT_DOWN

@SLD99:	LDA	#0
	STA	GP_TIMER
	LDA	#15
	STA	KEY_TIMER
	JMP	@SLD_LOOP
.endproc


.proc DBG_SELECT_DOWN
	SET_GAME_BG_PALETTE  GAME_BG_PALETTE_NORMAL

	LDADDR	PTR_0, MSG_DEBUG
	JSR	PRINT_INFO


@SLD_LOOP:
	JSR	GAME_NEXT_FRAME
	JSR	READ_JOYPAD

	JOYPAD_BR_IF_SELECT_HELD  @SLD05
	JSR	CLEAR_INFO
	LDA	#15
	STA	KEY_TIMER
	JMP	MAIN_GAME_LOOP
@SLD05:
	JOYPAD_BR_IF_START_NOT_PRESSED  @SLD06
	LDA	#10		;ITEM-FOUND-SOUND
	JSR	SOUND_SYSTEM_SFX_PLAY	;SOUND PLAY
	JSR	INIT_CHEATER
	JMP	@SLD_LOOP
@SLD06:
	JOYPAD_BR_IF_L_NOT_HELD  @SLD10
	LDA	KEY_TIMER
	BEQ	:+
	JMP	@SLD_LOOP
:	DEC	UNIT_LOC_X
	LDA	UNIT_LOC_X
	CMP	#$04
	BNE	:+
	INC	UNIT_LOC_X
:	LDA	#(PLAYER_DIR_L << 2)
	JMP	@SLD40
@SLD10:
	JOYPAD_BR_IF_R_NOT_HELD  @SLD20
	LDA	KEY_TIMER
	BEQ	:+
	JMP	@SLD_LOOP
:	INC	UNIT_LOC_X
	LDA	UNIT_LOC_X
	CMP	#$7B
	BNE	:+
	DEC	UNIT_LOC_X
:	LDA	#(PLAYER_DIR_R << 2)
	JMP	@SLD40
@SLD20:
	JOYPAD_BR_IF_U_NOT_HELD  @SLD30
	LDA	KEY_TIMER
	BEQ	:+
	JMP	@SLD_LOOP
:	DEC	UNIT_LOC_Y
	LDA	UNIT_LOC_Y
	CMP	#$02
	BNE	:+
	INC	UNIT_LOC_Y
:	LDA	#(PLAYER_DIR_U << 2)
	JMP	@SLD40
@SLD30:
	JOYPAD_BR_IF_D_NOT_HELD  @SLD50
	LDA	KEY_TIMER
	BEQ	:+
	JMP	@SLD_LOOP
:	INC	UNIT_LOC_Y
	LDA	UNIT_LOC_Y
	CMP	#$3D
	BNE	:+
	DEC	UNIT_LOC_Y
:	LDA	#(PLAYER_DIR_D << 2)
	JMP	@SLD40
@SLD40:
	STA	UNIT_TILE
	LDA	#4
	STA	KEY_TIMER
	LDA	#0
	STA	GP_TIMER
	JSR	ANIMATE_PLAYER
	JSR	CALCULATE_AND_REDRAW
	JMP	@SLD_LOOP
@SLD50:
	JMP	@SLD_LOOP
.endproc


.proc CYCLE_ITEM
	LDA	#13		;CHANGE-ITEM-SOUND
	JSR	SOUND_SYSTEM_SFX_PLAY	;SOUND PLAY
	LDA	SELECT_TIMEOUT
	CMP	#0
	BEQ	@CYIT0
	RTS
@CYIT0:	LDA	#3
	STA	SELECT_TIMEOUT	;RESET THE TIMEOUT
	LDA	#20
	STA	KEY_TIMER
	INC	SELECTED_ITEM
	LDA	SELECTED_ITEM
	CMP	#5
	BEQ	@CYIT1
	JMP	DISPLAY_ITEM
@CYIT1:	LDA	#0
	STA	SELECTED_ITEM
	JMP	DISPLAY_ITEM
.endproc

.proc CYCLE_WEAPON
	LDA	#12		;CHANGE WEAPON-SOUND
	JSR	SOUND_SYSTEM_SFX_PLAY	;SOUND PLAY
	LDA	SELECT_TIMEOUT
	CMP	#0
	BEQ	@CYWE0
	RTS
@CYWE0:	LDA	#3
	STA	SELECT_TIMEOUT	;RESET THE TIMEOUT
	LDA	#20
	STA	KEY_TIMER
	INC	SELECTED_WEAPON
	LDA	SELECTED_WEAPON
	CMP	#2
	BNE	@CYWE1
	JMP	DISPLAY_WEAPON
@CYWE1:	LDA	#0
	STA	SELECTED_WEAPON
	JMP	DISPLAY_WEAPON
.endproc

.proc USE_ITEM
	;check select timeout to prevent accidental double-tap
	LDA	SELECT_TIMEOUT
	CMP	#0
	BEQ	@UI01
	RTS
	;First figure out which item to use.
@UI01:	LDA	SELECTED_ITEM
	CMP	#1	;BOMB
	BNE	@UI02
	JMP	USE_BOMB
@UI02:	CMP	#2	;EMP
	BNE	@UI03
	JMP	USE_EMP
@UI03:	CMP	#3	;MEDKIT
	BNE	@UI04
	JMP	USE_MEDKIT
@UI04:	CMP	#4	;MAGNET
	BNE	@UI05
	JMP	USE_MAGNET
@UI05:	RTS
.endproc

.proc USE_BOMB
	LDADDR	PTR_0, MSG_ITEM_M
	JSR	PRINT_INFO
	LDADDR	PTR_0, MSG_PLACE
	JSR	PRINT_INFO
	LDADDR	PTR_0, MSG_CANCEL
	JSR	PRINT_INFO

	JSR	USER_SELECT_OBJECT

	JSR	CLEAR_INFO

	;NOW TEST TO SEE IF THAT SPOT IS OPEN
	JSR	BOMB_MAGNET_COMMON1
	BEQ	@BM30
	JMP	@BM3A				;If not, then exit routine.
@BM30:	;Now scan for any units at that location:
	JSR	CHECK_FOR_UNIT
	LDA	UNIT_FIND
	CMP	#255			;255 means no unit found.
	BEQ	@BM31
@BM3A:	JMP	BOMB_MAGNET_COMMON2
@BM31:	LDX	#28	;Start of weapons units
@BOMB1:	LDA	UNIT_TYPE,X
	CMP	#0
	BEQ	@BOMB2
	INX
	CPX	#32
	BNE	@BOMB1
	RTS	;no slots available right now, abort.
@BOMB2:	LDA	#6	;bomb AI
	STA	UNIT_TYPE,X
	LDA	#130	;bomb tile
	STA	UNIT_TILE,X
	LDA	MAP_X
	STA	UNIT_LOC_X,X
	LDA	MAP_Y
	STA	UNIT_LOC_Y,X
	LDA	#100		;How long until exposion?
	STA	UNIT_TIMER_A,X
	LDA	#0
	STA	UNIT_A,X
	DEC	INV_BOMBS
	JSR	DISPLAY_ITEM
	SETB	GAME_FLAG, F_REDRAW_FIELD
	LDA	#3	;3 cycles before next item can be used
	STA	SELECT_TIMEOUT ;pet version only
	LDA	#06		;move sound
	JSR	SOUND_SYSTEM_SFX_PLAY	;SOUND PLAY
	RTS
.endproc

.proc USE_MAGNET
	LDA	MAGNET_ACT	;only one magnet active at a time.
	CMP	#0
	BEQ	@MG32
	RTS
@MG32:	
	LDADDR	PTR_0, MSG_ITEM_M
	JSR	PRINT_INFO
	LDADDR	PTR_0, MSG_PLACE
	JSR	PRINT_INFO
	LDADDR	PTR_0, MSG_CANCEL
	JSR	PRINT_INFO

	JSR	USER_SELECT_OBJECT

	JSR	CLEAR_INFO

	;NOW TEST TO SEE IF THAT SPOT IS OPEN
	JSR	BOMB_MAGNET_COMMON1
	BEQ	@MG31
	JMP	BOMB_MAGNET_COMMON2
@MG31:	LDX	#28	;Start of weapons units
@MAG1:	LDA	UNIT_TYPE,X
	CMP	#0
	BEQ	@MAG2
	INX
	CPX	#32
	BNE	@MAG1
	RTS	;no slots available right now, abort.
@MAG2:	LDA	#20	;MAGNET AI
	STA	UNIT_TYPE,X
	LDA	#134	;MAGNET tile
	STA	UNIT_TILE,X
	LDA	MAP_X
	STA	UNIT_LOC_X,X
	LDA	MAP_Y
	STA	UNIT_LOC_Y,X
	LDA	#1		;How long until ACTIVATION
	STA	UNIT_TIMER_A,X
	LDA	#255		;how long does it live -A
	STA	UNIT_TIMER_B,X
	LDA	#3		;how long does it live -B
	STA	UNIT_A,X
	LDA	#1
	STA	MAGNET_ACT	;only one magnet allowed at a time.
	DEC	INV_MAGNET
	JSR	DISPLAY_ITEM
	SETB	GAME_FLAG, F_REDRAW_FIELD
	LDA	#06		;move sound
	JSR	SOUND_SYSTEM_SFX_PLAY	;SOUND PLAY
	RTS
.endproc

.proc BOMB_MAGNET_COMMON1
	CLRB	GAME_FLAG, F_CURSOR_ON
	LDA	CURSOR_X
	CLC
	ADC	MAP_WINDOW_X
	STA	MAP_X
	STA	MOVTEMP_UX
	LDA	CURSOR_Y
	CLC
	ADC	MAP_WINDOW_Y
	STA	MAP_Y
	STA	MOVTEMP_UY
	JSR	GET_TILE_FROM_MAP
	LDA	TILE
	TAY
	LDA	TILE_ATTRIB,Y
	AND	#%00000001		;is that spot available
	CMP	#%00000001		;for something to move onto it?
	RTS
.endproc

.proc BOMB_MAGNET_COMMON2
	JSR	CLEAR_INFO
	LDADDR	PTR_0, MSG_BLOCKED
	JSR	PRINT_INFO
	LDA	#11		;ERROR SOUND
	JSR	SOUND_SYSTEM_SFX_PLAY	;SOUND PLAY
	RTS
.endproc

.proc USE_EMP
	JSR	EMP_FLASH
	LDA	#3		;EMP sound
	JSR	SOUND_SYSTEM_SFX_PLAY	;SOUND PLAY
	DEC	INV_EMP
	JSR	DISPLAY_ITEM
	LDX	#1	;start with unit#1 (skip player)
@EMP1:	;CHECK THAT UNIT EXISTS
	LDA	UNIT_TYPE,X
	CMP	#0
	BEQ	@EMP5
	;CHECK HORIZONTAL POSITION
	LDA	UNIT_LOC_X,X
	CMP	MAP_WINDOW_X
	BLT	@EMP5
	LDA	MAP_WINDOW_X
	CLC
	ADC	#10
	CMP	UNIT_LOC_X,X
	BLT	@EMP5
	;NOW CHECK VERTICAL
	LDA	UNIT_LOC_Y,X
	CMP	MAP_WINDOW_Y
	BLT	@EMP5
	LDA	MAP_WINDOW_Y
	CLC
	ADC	#6
	CMP	UNIT_LOC_Y,X
	BLT	@EMP5
	LDA	#255
	STA	UNIT_TIMER_A,X
	;test to see if unit is above water
	LDA	UNIT_LOC_X,X
	STA	MAP_X
	LDA	UNIT_LOC_Y,X
	STA	MAP_Y
	JSR	GET_TILE_FROM_MAP
	LDA	TILE
	CMP	#204	;WATER
	BNE	@EMP5
	LDA	#5
	STA	UNIT_TYPE,X
	STA	UNIT_TIMER_A,X
	LDA	#60	;how long to show sparks.
	STA	UNIT_A,X
	LDA	#140	;Electrocuting tile
	STA	UNIT_TILE,X
@EMP5:	INX
	CPX	#28
	BNE	@EMP1
	LDADDR	PTR_0, MSG_EMPUSED
	JSR	PRINT_INFO
	LDA	#3	;3 cycles before next item can be used
	STA	SELECT_TIMEOUT
	RTS
.endproc

.proc USE_MEDKIT
	LDA	UNIT_HEALTH
	CMP	#12	;Do we even need the medkit?
	BNE	@UMK1
	RTS
@UMK1:	;Now figure out how many HP we need to be healthy.
	LDA	#12
	SEC
	SBC	UNIT_HEALTH
	STA	TEMP_A		;how many we need.
	LDA	INV_MEDKIT	;how many do we have?
	SEC
	SBC	TEMP_A
	BCC	@UMK2
	;we had more than we need, so go to full health.
	LDA	#12
	STA	UNIT_HEALTH
	LDA	INV_MEDKIT
	SEC
	SBC	TEMP_A
	STA	INV_MEDKIT
	JMP	@UMK3
@UMK2:	;we had less than we need, so we'll use what is available.
	LDA	INV_MEDKIT
	CLC
	ADC	UNIT_HEALTH
	STA	UNIT_HEALTH
	LDA	#0
	STA	INV_MEDKIT
@UMK3:	JSR	DISPLAY_PLAYER_HEALTH
	JSR	DISPLAY_ITEM
	LDA	#2		;MEDKIT SOUND
	JSR	SOUND_SYSTEM_SFX_PLAY	;SOUND PLAY
	LDADDR	PTR_0, MSG_MUCHBET
	JSR	PRINT_INFO
	RTS
.endproc


.proc MOVE_UP
	LDA	UNIT_TILE
	AND	#%00000011
	ORA	#(PLAYER_DIR_U << 2)
	STA	UNIT_TILE
	LDA	#0
	STA	UNIT
	LDA	#%00000001
	STA	MOVE_TYPE
	JSR	REQUEST_WALK_UP
	JMP	AFTER_MOVE
.endproc
	
.proc MOVE_DOWN
	LDA	UNIT_TILE
	AND	#%00000011
	ORA	#(PLAYER_DIR_D << 2)
	STA	UNIT_TILE
	LDA	#0
	STA	UNIT
	LDA	#%00000001
	STA	MOVE_TYPE
	JSR	REQUEST_WALK_DOWN
	JMP	AFTER_MOVE
.endproc

.proc MOVE_LEFT
	LDA	UNIT_TILE
	AND	#%00000011
	ORA	#(PLAYER_DIR_L << 2)
	STA	UNIT_TILE
	LDA	#0
	STA	UNIT
	LDA	#%00000001
	STA	MOVE_TYPE
	JSR	REQUEST_WALK_LEFT
	JMP	AFTER_MOVE
.endproc
	
.proc MOVE_RIGHT
	LDA	UNIT_TILE
	AND	#%00000011
	ORA	#(PLAYER_DIR_R << 2)
	STA	UNIT_TILE
	LDA	#0
	STA	UNIT
	LDA	#%00000001
	STA	MOVE_TYPE
	JSR	REQUEST_WALK_RIGHT
	JMP	AFTER_MOVE
.endproc
	
;This routine handles things that are in common to
;all 4 directions of movement.
.proc AFTER_MOVE
	LDA	MOVE_RESULT
	CMP	#1
	BEQ	@AMS01
	LDA	UNIT_TILE
	AND	#%11111110
	STA	UNIT_TILE
@AMS01:	;now reset key-repeat rate
	JSR	ANIMATE_PLAYER
	JSR	CALCULATE_AND_REDRAW
	BBS	GAME_FLAG, F_KEY_FAST, @AMS02
	;FIRST REPEAT
	LDA	#15
	STA	KEY_TIMER
	SETB	GAME_FLAG, F_KEY_FAST
	JMP	MAIN_GAME_LOOP
@AMS02:	;SUBSEQUENT REPEATS
	LDA	#6
	STA	KEY_TIMER
	JMP	MAIN_GAME_LOOP
.endproc


.proc FIRE_UP
	LDA	SELECTED_WEAPON
	CMP	#0
	BNE	@FRU0
	RTS
@FRU0:	CMP	#1
	BNE	@FRU1
	JMP	FIRE_UP_PISTOL
@FRU1:	JMP	FIRE_UP_PLASMA
.endproc

.proc FIRE_UP_PISTOL
	LDA	AMMO_PISTOL
	CMP	#0
	BNE	@FU00
	RTS
@FU00:	LDX	#28
@FU01:	LDA	UNIT_TYPE,X
	CMP	#0
	BEQ	@FU02
	INX
	CPX	#32	;max unit for weaponsfire
	BNE	@FU01
	RTS
@FU02:	LDA	#12	;Fire pistol up AI routine
	STA	UNIT_TYPE,X
	LDA	#244	;tile for vertical weapons fire
	STA	UNIT_TILE,X
	LDA	#3		;travel distance.
	STA	UNIT_A,X
	LDA	#0		;weapon-type = pistol
	STA	UNIT_B,X
	JMP	AFTER_FIRE
.endproc

.proc FIRE_UP_PLASMA
	LDA	BIG_EXP_ACT
	CMP	#1
	BEQ	@FUP3
	LDA	PLASMA_ACT
	CMP	#1
	BEQ	@FUP3
	LDA	AMMO_PLASMA
	CMP	#0
	BNE	@FUP0
@FUP3:	RTS
@FUP0:	LDX	#28
@FUP1:	LDA	UNIT_TYPE,X
	CMP	#0
	BEQ	@FUP2
	INX
	CPX	#32	;max unit for weaponsfire
	BNE	@FUP1
	RTS
@FUP2:	LDA	#12	;Fire pistol up AI routine
	STA	UNIT_TYPE,X
	LDA	#240	;tile for vertical plasma bolt
	STA	UNIT_TILE,X
	LDA	#3		;travel distance.
	STA	UNIT_A,X
	LDA	#1		;weapon-type = plasma
	STA	UNIT_B,X
	STA	PLASMA_ACT
	JMP	AFTER_FIRE
.endproc

.proc FIRE_DOWN
	LDA	SELECTED_WEAPON
	CMP	#0
	BNE	@FRD0
	RTS
@FRD0:	CMP	#1
	BNE	@FRD1
	JMP	FIRE_DOWN_PISTOL
@FRD1:	JMP	FIRE_DOWN_PLASMA
.endproc

.proc FIRE_DOWN_PISTOL
	LDA	AMMO_PISTOL
	CMP	#0
	BNE	@FD00
	RTS
@FD00:	LDX	#28
@FD01:	LDA	UNIT_TYPE,X
	CMP	#0
	BEQ	@FD02
	INX
	CPX	#32	;max unit for weaponsfire
	BNE	@FD01
	RTS
@FD02:	LDA	#13	;Fire pistol DOWN AI routine
	STA	UNIT_TYPE,X
	LDA	#244	;tile for vertical weapons fire
	STA	UNIT_TILE,X
	LDA	#3		;travel distance.
	STA	UNIT_A,X
	LDA	#0		;weapon-type = pistol
	STA	UNIT_B,X
	JMP	AFTER_FIRE
.endproc

.proc FIRE_DOWN_PLASMA
	LDA	BIG_EXP_ACT
	CMP	#1
	BEQ	@FDP3
	LDA	PLASMA_ACT
	CMP	#1
	BEQ	@FDP3
	LDA	AMMO_PLASMA
	CMP	#0
	BNE	@FDP0
@FDP3:	RTS
@FDP0:	LDX	#28
@FDP1:	LDA	UNIT_TYPE,X
	CMP	#0
	BEQ	@FDP2
	INX
	CPX	#32	;max unit for weaponsfire
	BNE	@FDP1
	RTS
@FDP2:	LDA	#13	;Fire pistol DOWN AI routine
	STA	UNIT_TYPE,X
	LDA	#240	;tile for vertical weapons fire
	STA	UNIT_TILE,X
	LDA	#3		;travel distance.
	STA	UNIT_A,X
	LDA	#1		;weapon-type = plasma
	STA	UNIT_B,X
	STA	PLASMA_ACT
	JMP	AFTER_FIRE
.endproc

.proc FIRE_LEFT
	LDA	SELECTED_WEAPON
	CMP	#0
	BNE	@FRL0
	RTS
@FRL0:	CMP	#1
	BNE	@FRL1
	JMP	FIRE_LEFT_PISTOL
@FRL1:	JMP	FIRE_LEFT_PLASMA
.endproc

.proc FIRE_LEFT_PISTOL
	LDA	AMMO_PISTOL
	CMP	#0
	BNE	@FL00
	RTS
@FL00:	LDX	#28
@FL01:	LDA	UNIT_TYPE,X
	CMP	#0
	BEQ	@FL02
	INX
	CPX	#32	;max unit for weaponsfire
	BNE	@FL01
	RTS
@FL02:	LDA	#14	;Fire pistol LEFT AI routine
	STA	UNIT_TYPE,X
	LDA	#245	;tile for horizontal weapons fire
	STA	UNIT_TILE,X
	LDA	#5		;travel distance.
	STA	UNIT_A,X
	LDA	#0		;weapon-type = pistol
	STA	UNIT_B,X
	JMP	AFTER_FIRE
.endproc

.proc FIRE_LEFT_PLASMA
	LDA	BIG_EXP_ACT
	CMP	#1
	BEQ	@FLP3
	LDA	PLASMA_ACT
	CMP	#1
	BEQ	@FLP3
	LDA	AMMO_PLASMA
	CMP	#0
	BNE	@FLP0
@FLP3:	RTS
@FLP0:	LDX	#28
@FLP1:	LDA	UNIT_TYPE,X
	CMP	#0
	BEQ	@FLP2
	INX
	CPX	#32	;max unit for weaponsfire
	BNE	@FLP1
	RTS
@FLP2:	LDA	#14	;Fire pistol LEFT AI routine
	STA	UNIT_TYPE,X
	LDA	#241	;tile for horizontal weapons fire
	STA	UNIT_TILE,X
	LDA	#5		;travel distance.
	STA	UNIT_A,X
	LDA	#1		;weapon-type = plasma
	STA	UNIT_B,X
	STA	PLASMA_ACT
	JMP	AFTER_FIRE
.endproc

.proc FIRE_RIGHT
	LDA	SELECTED_WEAPON
	CMP	#0
	BNE	@FRR0
	RTS
@FRR0:	CMP	#1
	BNE	@FRR1
	JMP	FIRE_RIGHT_PISTOL
@FRR1:	JMP	FIRE_RIGHT_PLASMA
.endproc

.proc FIRE_RIGHT_PISTOL
	LDA	AMMO_PISTOL
	CMP	#0
	BNE	@FR00
	RTS
@FR00:	LDX	#28
@FR01:	LDA	UNIT_TYPE,X
	CMP	#0
	BEQ	@FR02
	INX
	CPX	#32	;max unit for weaponsfire
	BNE	@FR01
	RTS
@FR02:	LDA	#15	;Fire pistol RIGHT AI routine
	STA	UNIT_TYPE,X
	LDA	#245	;tile for horizontal weapons fire
	STA	UNIT_TILE,X
	LDA	#5		;travel distance.
	STA	UNIT_A,X
	LDA	#0		;weapon-type = pistol
	STA	UNIT_B,X
	JMP	AFTER_FIRE
.endproc

.proc FIRE_RIGHT_PLASMA
	LDA	BIG_EXP_ACT
	CMP	#1
	BEQ	@FRP3
	LDA	PLASMA_ACT
	CMP	#1
	BEQ	@FRP3
	LDA	AMMO_PLASMA
	CMP	#0
	BNE	@FRP0
@FRP3:	RTS
@FRP0:	LDX	#28
@FRP1:	LDA	UNIT_TYPE,X
	CMP	#0
	BEQ	@FRP2
	INX
	CPX	#32	;max unit for weaponsfire
	BNE	@FRP1
	RTS
@FRP2:	LDA	#15	;Fire pistol RIGHT AI routine
	STA	UNIT_TYPE,X
	LDA	#241	;tile for horizontal weapons fire
	STA	UNIT_TILE,X
	LDA	#5		;travel distance.
	STA	UNIT_A,X
	LDA	#1		;weapon-type = plasma
	STA	UNIT_B,X
	STA	PLASMA_ACT
	JMP	AFTER_FIRE
.endproc

.proc AFTER_FIRE
	LDA	#9		;travel distance.
	STA	UNIT_A,X
	LDA	#0
	STA	UNIT_TIMER_A,X
	LDA	UNIT_LOC_X
	STA	UNIT_LOC_X,X
	LDA	UNIT_LOC_Y
	STA	UNIT_LOC_Y,X
	STX	UNIT
	LDA	SELECTED_WEAPON
	CMP	#2
	BEQ	@AF01
	LDA	#09		;PISTOL-SOUND
	JSR	SOUND_SYSTEM_SFX_PLAY	;SOUND PLAY
	DEC	AMMO_PISTOL
	JSR	DISPLAY_WEAPON
	RTS
@AF01:	LDA	#08		;PLASMA-GUN-SOUND
	JSR	SOUND_SYSTEM_SFX_PLAY	;SOUND PLAY
	DEC	AMMO_PLASMA
	JSR	DISPLAY_WEAPON
	RTS
.endproc


; ------------------------------------------------------------------------------
;This routine is invoked when the user presses S to search
;an object such as a crate, chair, or plant.
.pushseg
.segment BANK(BK_GAME_CODE)
.proc SEARCH_OBJECT
	LDADDR	PTR_0, MSG_SEARCH_M
	JSR	PRINT_INFO
	LDADDR	PTR_0, MSG_SELECT
	JSR	PRINT_INFO
	LDADDR	PTR_0, MSG_CANCEL
	JSR	PRINT_INFO
	
	JSR	USER_SELECT_OBJECT

	; JSR	CLEAR_INFO
	
	SETB	GAME_FLAG, F_REDRAW_FIELD
@CHS1:	;first check of object is searchable
	JSR	CALC_COORDINATES
	JSR	GET_TILE_FROM_MAP
	LDX	TILE
	LDA	TILE_ATTRIB,X
	AND	#%01000000	;can search attribute
	CMP	#%01000000
	BEQ	@CHS2
	CLRB	GAME_FLAG, F_CURSOR_ON
	SETB	GAME_FLAG, F_TRANSFER_FIELD
	JSR	GAME_NEXT_FRAME
	
	JSR	CLEAR_INFO
	JMP	@CHS3
@CHS2:	;is the tile a crate?
	LDX	TILE
	CPX	#041	;BIG CRATE
	BEQ	@CHS2B
	CPX	#045	;small CRATE
	BEQ	@CHS2B
	CPX	#199	;"Pi" CRATE
	BEQ	@CHS2B
	JMP	@CHS2C
@CHS2B:	LDA	DESTRUCT_PATH,X
	STA	TILE
	JSR	PLOT_TILE_TO_MAP
@CHS2C:	;Now check if there is an object there.
	
	SETB	GAME_FLAG, F_TRANSFER_FIELD
	JSR	GAME_NEXT_FRAME

	JSR	CLEAR_INFO
	LDADDR	PTR_0, MSG_SEARCHING
	JSR	PRINT_INFO

	LDA	#8
	PHA
	; STA	SEARCHBAR
@SOBJ1:	LDA	#18	;delay time between search periods
	STA	GP_TIMER
@SOBJ2:
	SETB	GAME_FLAG, F_TRANSFER_FIELD
	JSR	GAME_NEXT_FRAME
	JSR	READ_JOYPAD
	LDA	GP_TIMER
	CMP	#0
	BNE	@SOBJ2
	LDADDR	PTR_0, MSG_DOT
	JSR	PRINT_INFO
	; DEC	SEARCHBAR
	PLA
	SEC
	SBC	#1
	PHA
	BNE	@SOBJ1
	PLA
	JSR	SCROLL_INFO

	CLRB	GAME_FLAG, F_CURSOR_ON
	JSR	CALC_COORDINATES
	JSR	CHECK_FOR_HIDDEN_UNIT
	LDA	UNIT_FIND
	CMP	#255
	BNE	@SOBJ5
@CHS3:	LDADDR	PTR_0, MSG_NOTFOUND
	JSR	PRINT_INFO
	RTS
@SOBJ5:
	LDX	UNIT_FIND
	LDA	UNIT_TYPE,X
	STA	TEMP_A		;store object type
	LDA	UNIT_A,X
	STA	TEMP_B		;store secondary info
	LDA	#0	;DELETE ITEM ONCE FOUND
	STA	UNIT_TYPE,X
	;***NOW PROCESS THE ITEM FOUND***
	LDA	#10		;ITEM-FOUND-SOUND
	JSR	SOUND_SYSTEM_SFX_PLAY	;SOUND PLAY
	LDA	TEMP_A
	CMP	#128	;key
	BEQ	@SOBJ10
	JMP	@SOBJ15
@SOBJ10:
	LDA	TEMP_B		;WHICH SORT OF KEY?
	CMP	#00
	BNE	@SOBJK1
	LDA	KEYS
	ORA	#%00000001	;Add spade key
	STA	KEYS
	JMP	@SOBJ12
@SOBJK1:	CMP	#01
	BNE	@SOBJK2
	LDA	KEYS
	ORA	#%00000010	;Add heart key
	STA	KEYS
	JMP	@SOBJ12
@SOBJK2:
	LDA	KEYS
	ORA	#%00000100	;Add star key
	STA	KEYS
@SOBJ12:
	LDADDR	PTR_0, MSG_FOUNDKEY
	JSR	PRINT_INFO
	JSR	DISPLAY_KEYS
	RTS
@SOBJ15:
	CMP	#129	;TIME BOMB
	BNE	@SOBJ17
	LDA	TEMP_B
	CLC
	ADC	INV_BOMBS
	STA	INV_BOMBS
	LDADDR	PTR_0, MSG_FOUNDBOMB
	JSR	PRINT_INFO
	JSR	DISPLAY_ITEM
	RTS
@SOBJ17:
	CMP	#130	;EMP
	BNE	@SOBJ20
	LDA	TEMP_B
	CLC
	ADC	INV_EMP
	STA	INV_EMP
	LDADDR	PTR_0, MSG_FOUNDEMP
	JSR	PRINT_INFO
	JSR	DISPLAY_ITEM
	RTS
@SOBJ20:
	CMP	#131	;PISTOL
	BNE	@SOBJ21
	LDA	TEMP_B
	CLC
	ADC	AMMO_PISTOL
	STA	AMMO_PISTOL
	BCC	@SOBJ2A	;If we rolled over past 255
	LDA	#255	;set it to 255.
	STA	AMMO_PISTOL
@SOBJ2A:
	LDADDR	PTR_0, MSG_FOUNDGUN
	JSR	PRINT_INFO
	JSR	DISPLAY_WEAPON
@SOBJ21:
	CMP	#132	;PLASMA GUN
	BNE	@SOBJ22
	LDA	TEMP_B
	CLC
	ADC	AMMO_PLASMA
	STA	AMMO_PLASMA
	LDADDR	PTR_0, MSG_FOUNDPLAS
	JSR	PRINT_INFO
	JSR	DISPLAY_WEAPON
@SOBJ22:
	CMP	#133	;MEDKIT
	BNE	@SOBJ23
	LDA	TEMP_B
	CLC
	ADC	INV_MEDKIT
	STA	INV_MEDKIT
	LDADDR	PTR_0, MSG_FOUNDMED
	JSR	PRINT_INFO
	JSR	DISPLAY_ITEM
@SOBJ23:
	CMP	#134	;MAGNET
	BNE	@SOBJ99
	LDA	TEMP_B
	CLC
	ADC	INV_MAGNET
	STA	INV_MAGNET
	LDADDR	PTR_0, MSG_FOUNDMAG
	JSR	PRINT_INFO
	JSR	DISPLAY_ITEM
@SOBJ99:	;ADD CODE HERE FOR OTHER OBJECT TYPES
	RTS
.endproc
.popseg

.pushseg
.segment BANK(BK_GAME_CODE)
.proc MOVE_OBJECT
	LDADDR	PTR_0, MSG_MOVE_M
	JSR	PRINT_INFO
	LDADDR	PTR_0, MSG_SELECT
	JSR	PRINT_INFO
	LDADDR	PTR_0, MSG_CANCEL
	JSR	PRINT_INFO

	JSR	USER_SELECT_OBJECT
	
	LDADDR	PTR_0, MSG_MOVE_M
	JSR	PRINT_INFO
	LDADDR	PTR_0, MSG_MOVE
	JSR	PRINT_INFO
	LDADDR	PTR_0, MSG_CANCEL
	JSR	PRINT_INFO
	; LDA	UNIT
	;now test that object to see if it
	;is allowed to be moved.
@MV10:	
	CLRB	GAME_FLAG, F_CURSOR_ON
	JSR	CALC_COORDINATES
	JSR	CHECK_FOR_HIDDEN_UNIT
	LDA	UNIT_FIND
	STA	MOVTEMP_U
	JSR	GET_TILE_FROM_MAP
	LDA	TILE
	TAY
	LDA	TILE_ATTRIB,Y
	AND	#%00000100		;can it be moved?
	CMP	#%00000100
	BEQ	@MV11
	JSR	CLEAR_INFO
	LDADDR	PTR_0, MSG_CANTMOVE
	JSR	PRINT_INFO
	LDA	#11		;ERROR SOUND
	JSR	SOUND_SYSTEM_SFX_PLAY	;SOUND PLAY
	RTS
@MV11:	LDA	TILE
	STA	MOVTEMP_O	;Store which tile it is we are moving
	LDA	MAP_X
	STA	MOVTEMP_X	;Store original location of object
	LDA	MAP_Y
	STA	MOVTEMP_Y
	SETB	GAME_FLAG, F_CURSOR_ON
	JSR	DISPLAY_CURSOR
	;NOW ASK THE USER WHICH DIRECTION TO MOVE IT TO
@MV15:	
	JSR	GAME_NEXT_FRAME
	JSR	READ_JOYPAD
	LDA	UNIT_TYPE
	CMP	#0	;Did player die wile moving something?
	BNE	@MVCONT2
	CLRB	GAME_FLAG, F_CURSOR_ON
	RTS
@MVCONT2:
@SMV30:	JOYPAD_BR_IF_R_NOT_PRESSED  @SMV31
	INC	CURSOR_X
	LDA	UNIT_TILE
	AND	#%00000011
	ORA	#(PLAYER_DIR_R << 2)
	STA	UNIT_TILE
	JMP	@MV25
@SMV31:	JOYPAD_BR_IF_L_NOT_PRESSED  @SMV32
	DEC	CURSOR_X
	LDA	UNIT_TILE
	AND	#%00000011
	ORA	#(PLAYER_DIR_L << 2)
	STA	UNIT_TILE
	JMP	@MV25
@SMV32:	JOYPAD_BR_IF_D_NOT_PRESSED  @SMV33
	INC	CURSOR_Y
	LDA	UNIT_TILE
	AND	#%00000011
	ORA	#(PLAYER_DIR_D << 2)
	STA	UNIT_TILE
	JMP	@MV25
@SMV33:	JOYPAD_BR_IF_U_NOT_PRESSED  @SMV34
	DEC	CURSOR_Y
	LDA	UNIT_TILE
	AND	#%00000011
	ORA	#(PLAYER_DIR_U << 2)
	STA	UNIT_TILE
	JMP	@MV25

@SMV34:	JOYPAD_BR_IF_B_NOT_PRESSED  @SMV37
@SMV36:	CLRB	GAME_FLAG, F_CURSOR_ON
	JSR	CLEAR_INFO
	RTS
@SMV37:
	JMP	@MV15
	;NOW TEST TO SEE IF THAT SPOT IS OPEN
@MV25:	CLRB	GAME_FLAG, F_CURSOR_ON
	LDA	CURSOR_X
	CLC
	ADC	MAP_WINDOW_X
	STA	MAP_X
	STA	MOVTEMP_UX
	LDA	CURSOR_Y
	CLC
	ADC	MAP_WINDOW_Y
	STA	MAP_Y
	STA	MOVTEMP_UY
	JSR	GET_TILE_FROM_MAP

	LDA	#5
	STA	CURSOR_X
	LDA	#3
	STA	CURSOR_Y
	LDA	UNIT_TILE
	LSR
	LSR
	CMP	#3	; Right
	BNE	:+
	INC	CURSOR_X
	JMP	@MV26
:	CMP	#2	; Up
	BNE	:+
	DEC	CURSOR_Y
	JMP	@MV26
:	CMP	#1	; Left
	BNE	:+
	DEC	CURSOR_X
	JMP	@MV26
:			; Down
	INC	CURSOR_Y
@MV26:

	LDA	TILE
	TAY
	LDA	TILE_ATTRIB,Y
	AND	#%00100000	;is that spot available
	CMP	#%00100000	;for something to move onto it?
	BEQ	@MV30
	JMP	@MV3A		;If not, then exit routine.
@MV30:	;Now scan for any units at that location:
	JSR	CHECK_FOR_UNIT
	LDA	UNIT_FIND
	CMP	#255		;255 means no unit found.
	BEQ	@MV31
@MV3A:	JSR	CLEAR_INFO
	LDADDR	PTR_0, MSG_BLOCKED
	JSR	PRINT_INFO
	LDA	#11		;ERROR SOUND
	JSR	SOUND_SYSTEM_SFX_PLAY	;SOUND PLAY
	RTS
@MV31:	; TODO: change sound
	; LDA	#06		;move sound
	; JSR	SOUND_SYSTEM_SFX_PLAY	;SOUND PLAY
	LDY	#0
	LDA	(PTR_1),Y	;Grab current object
	STA	MOVTEMP_D
	LDA	MOVTEMP_O
	STA	(PTR_1),Y	;replace with obect we are moving
	LDA	MOVTEMP_X	;RETRIEVE original location of object
	STA	MAP_X
	LDA	MOVTEMP_Y
	STA	MAP_Y
	JSR	GET_TILE_FROM_MAP
	LDA	MOVTEMP_D
	CMP	#148		;trash compactor tile
	BNE	@MV31A
	LDA	#09		;Floor tile
@MV31A:
	STA	(PTR_1),Y	; Replace former location
	SETB	GAME_FLAG, F_REDRAW_FIELD	; See the result
	LDA	MOVTEMP_U
	CMP	#255
	BNE	@MV32
	JMP	@MV33
@MV32:	LDX	MOVTEMP_U	; if hidden unit was present
	LDA	MOVTEMP_UX	; also move its location
	STA	UNIT_LOC_X,X
	LDA	MOVTEMP_UY
	STA	UNIT_LOC_Y,X
@MV33:	LDA	MOVTEMP_X	; move player to old location of object
	STA	UNIT_LOC_X
	LDA	MOVTEMP_Y
	STA	UNIT_LOC_Y
	JSR	ANIMATE_PLAYER
	JSR	CALCULATE_AND_REDRAW
	JMP	@MV10
	; RTS
.endproc
.popseg

.pushseg
.segment "RAM"
MOVTEMP_O:	.RES 1	;origin tile
MOVTEMP_D:	.RES 1	;destination tile
MOVTEMP_X:	.RES 1	;x-coordinate
MOVTEMP_Y:	.RES 1	;y-coordinate
MOVTEMP_U:	.RES 1	;unit number (255=none)
MOVTEMP_UX:	.RES 1
MOVTEMP_UY:	.RES 1
.popseg


; ------------------------------------------------------------------------------
;combines cursor location with window location
;to determine coordinates for MAP_X and MAP_Y
.proc CALC_COORDINATES
	LDA	CURSOR_X
	CLC
	ADC	MAP_WINDOW_X
	STA	MAP_X
	LDA	CURSOR_Y
	CLC
	ADC	MAP_WINDOW_Y
	STA	MAP_Y
	RTS
.endproc

;This routine is called by routines such as the move, search,
;or use commands.  It displays a cursor and allows the user
;to pick a direction of an object.
.proc USER_SELECT_OBJECT
	LDA	#16		;beep sound
	JSR	SOUND_SYSTEM_SFX_PLAY	;SOUND PLAY
	LDA	#5
	STA	CURSOR_X
	LDA	#3
	STA	CURSOR_Y
	SETB	GAME_FLAG, F_CURSOR_ON
	JSR	DISPLAY_CURSOR
	;First ask user which object to move
@MV01:	
	JSR	GAME_NEXT_FRAME
	JSR	READ_JOYPAD
	LDA	UNIT_TYPE
	CMP	#0	;Did player die wile moving something?
	BNE	@MVCONT
	CLRB	GAME_FLAG, F_CURSOR_ON
	RTS
@MVCONT:
	;SNES controls for this routine
@MVS02:	JOYPAD_BR_IF_R_NOT_PRESSED  @MVS03
	INC	CURSOR_X
	RTS
@MVS03:	JOYPAD_BR_IF_L_NOT_PRESSED  @MVS04
	DEC	CURSOR_X
	RTS
@MVS04:	JOYPAD_BR_IF_D_NOT_PRESSED  @MVS05
	INC	CURSOR_Y
	RTS
@MVS05:	JOYPAD_BR_IF_U_NOT_PRESSED  @MVS06
	DEC	CURSOR_Y
	RTS
@MVS06:	JOYPAD_BR_IF_B_NOT_PRESSED  @MVS10
@MVS08:	CLRB	GAME_FLAG, F_CURSOR_ON
	RTS
@MVS10:
	JMP	@MV01
.endproc


; calculates the map window offset based on the players 
; position and marks the window to be redrawn
.proc CALCULATE_AND_REDRAW
	LDA	UNIT_LOC_X	;no index needed since it's player unit
	SEC
	SBC	#5
	STA	MAP_WINDOW_X
	LDA	UNIT_LOC_Y	;no index needed since it's player unit
	SEC
	SBC	#3
	STA	MAP_WINDOW_Y
	SETB	GAME_FLAG, F_REDRAW_FIELD
	RTS
.endproc


; ------------------------------------------------------------------------------
;This routine is where the MAP is displayed on the screen
;This is a temporary routine, taken from the map editor.
.proc DRAW_MAP_WINDOW
	;REMOVE ANY PENDING TRANSFER REQUEST
	CLRB	GAME_FLAG, F_TRANSFER_FIELD
	JSR	MAP_PLOT_BG
	JSR	MAP_PLOT_FG
	
	;CHECK FOR CURSOR
	BBC	GAME_FLAG, F_CURSOR_ON, @DM11	;Is cursor even on?
	JSR	DISPLAY_CURSOR
	JMP	@DM12
@DM11:	JSR	HIDE_CURSOR
@DM12:	SETB	GAME_FLAG, F_TRANSFER_FIELD
	RTS
.endproc



; ------------------------------------------------------------------------------

; ------------------------------------------------------------------------------
.proc DISPLAY_ITEM
	JSR	PRESELECT_ITEM
@DSIT0:	LDA	SELECTED_ITEM
	CMP	#0	;no items to show
	BNE	@DSIT1
	;add routine to draw blank space
	JMP	@DSIT_END
@DSIT1:	CMP	#5	;number too high.
	BNE	@DSITA
	LDA	#0
	STA	SELECTED_ITEM
	JMP	@DSIT_END
@DSITA:	CMP	#1	;bomb
	BNE	@DSIT3
	LDA	INV_BOMBS
	CMP	#0	;did we run out?
	BNE	@DSIT2
	INC	SELECTED_ITEM
	JMP	@DSIT0
@DSIT2:	JSR	DISPLAY_TIMEBOMB
	JMP	@DSIT_END
@DSIT3:	CMP	#2	;emp
	BNE	@DSIT5
	LDA	INV_EMP
	CMP	#0	;did we run out?
	BNE	@DSIT4
	INC	SELECTED_ITEM
	JMP	@DSIT0
@DSIT4:	JSR	DISPLAY_EMP
	JMP	@DSIT_END
@DSIT5:	CMP	#3	;medkit
	BNE	@DSIT7
	LDA	INV_MEDKIT
	CMP	#0	;did we run out?
	BNE	@DSIT6
	INC	SELECTED_ITEM
	JMP	@DSIT0
@DSIT6:	JSR	DISPLAY_MEDKIT
	JMP	@DSIT_END
@DSIT7:	CMP	#4	;magnet
	BNE	@DSIT9
	LDA	INV_MAGNET
	CMP	#0	;did we run out?
	BNE	@DSIT8
	INC	SELECTED_ITEM
	JMP	@DSIT9
@DSIT8:	JSR	DISPLAY_MAGNET
	JMP	@DSIT_END
@DSIT9:	LDA	#0
	STA	SELECTED_ITEM
	JSR	PRESELECT_ITEM
	JMP	DISPLAY_ITEM
@DSIT_END:
	; TODO: update UI num
	LDADDR	PTR_0, ITM_NUM_BUFFER
	LDA	SELECTED_ITEM
	CMP	#1	;bomb
	BNE	:+
	LDA	INV_BOMBS
	JMP	@disp
:	CMP	#2	;emp
	BNE	:+
	LDA	INV_EMP
	JMP	@disp
:	CMP	#3	;medkit
	BNE	:+
	LDA	INV_MEDKIT
	JMP	@disp
:	CMP	#4	;magnet
	BNE	@else
	LDA	INV_MAGNET
@disp:	JSR	DEC2CHAR
	RTS
@else:
	LDA	#' '
	STA	ITM_NUM_BUFFER+0
	STA	ITM_NUM_BUFFER+1
	STA	ITM_NUM_BUFFER+2
	RTS
.endproc

;This routine checks to see if currently selected
;item is zero.  And if it is, then it checks inventories
;of other items to decide which item to automatically
;select for the user.
.proc PRESELECT_ITEM
	LDA	SELECTED_ITEM
	CMP	#0		;If item already selected, return
	BEQ	@PRSI1
	RTS
@PRSI1:	LDA	INV_BOMBS
	CMP	#0
	BEQ	@PRSI2
	LDA	#1	;BOMB
	STA	SELECTED_ITEM
	RTS
@PRSI2:	LDA	INV_EMP
	CMP	#0
	BEQ	@PRSI3
	LDA	#2	;EMP
	STA	SELECTED_ITEM
	RTS
@PRSI3:	LDA	INV_MEDKIT
	CMP	#0
	BEQ	@PRSI4
	LDA	#3	;MEDKIT
	STA	SELECTED_ITEM
	RTS
@PRSI4:	LDA	INV_MAGNET
	CMP	#0
	BEQ	@PRSI5
	LDA	#4	;MAGNET
	STA	SELECTED_ITEM
	RTS
@PRSI5:	;Nothing found in inventory at this point, so set
	;selected-item to zero.
	LDA	#0	;nothing in inventory
	STA	SELECTED_ITEM
	JSR	DISPLAY_BLANK_ITEM
	RTS
.endproc

; ------------------------------------------------------------------------------
.proc DISPLAY_WEAPON
	JSR	PRESELECT_WEAPON
	LDA	SELECTED_WEAPON

@DSWP0:
	CMP	#0	;no weapon to show
	BNE	@DSWP1
	JSR	DISPLAY_BLANK_WEAPON
	JMP	@DSWP_END

@DSWP1:	
	CMP	#1	;PISTOL
	BNE	@DSWP3
	LDA	AMMO_PISTOL
	CMP	#0	;did we run out?
	BNE	@DSWP2
	LDA	#0
	STA	SELECTED_WEAPON
	JMP	DISPLAY_WEAPON
@DSWP2:	JSR	DISPLAY_PISTOL
	JMP	@DSWP_END

@DSWP3:	CMP	#2	;PLASMA GUN
	BNE	@DSWP5
	LDA	AMMO_PLASMA
	CMP	#0	;did we run out?
	BNE	@DSWP4
	LDA	#0
	STA	SELECTED_WEAPON
	JMP	DISPLAY_WEAPON
@DSWP4:	JSR	DISPLAY_PLASMA_GUN
	JMP	@DSWP_END
@DSWP5:	LDA	#0
	STA	SELECTED_WEAPON	;should never happen
	JMP	DISPLAY_WEAPON

@DSWP_END:
	; TODO: update UI num
	LDADDR	PTR_0, WPN_NUM_BUFFER
	LDA	SELECTED_WEAPON
	CMP	#1	;pistol
	BNE	:+
	LDA	AMMO_PISTOL
	JMP	@disp
:	CMP	#2	;plasma gun
	BNE	@else
	LDA	AMMO_PLASMA
@disp:	JSR	DEC2CHAR
	RTS
@else:
	LDA	#' '
	STA	WPN_NUM_BUFFER+0
	STA	WPN_NUM_BUFFER+1
	STA	WPN_NUM_BUFFER+2
	RTS
.endproc

; This routine checks if currently no weapons are selected.
; If that is the case, it checks which weapons still has ammo
; and selects it. Otherwise the routine returns.
.proc PRESELECT_WEAPON
	LDA	SELECTED_WEAPON
	BEQ	@PRSW1		;is no weapon selected?
	RTS
@PRSW1:	
 	LDA	AMMO_PISTOL
	BEQ	@PRSW2		;is ammo zero?
	LDA	#1		;PISTOL
	STA	SELECTED_WEAPON
	RTS
@PRSW2:	
 	LDA	AMMO_PLASMA
	BEQ	@PRSW4		;is ammo zero?
	LDA	#2		;PLASMAGUN
	STA	SELECTED_WEAPON
@PRSW4:	
	RTS
.endproc


.proc EMP_FLASH
	LDA	#10
	STA	EMP_TIMER
	SET_GAME_BG_PALETTE  GAME_BG_PALETTE_INVERT
	SETB	GAME_FLAG, F_REDRAW_FIELD
	RTS
.endproc

;This routine animates the tile #204 (water)
;and also tile 148 (trash compactor)
.proc ANIMATE_WATER
	LDA	COUNTER
	REPEAT	4, LSR
	AND	#$03
	TAX
	LDA	ANIMATION_IDX_0,X
	STA	ANIMATION_INX+0
	LDA	ANIMATION_IDX_1,X
	STA	ANIMATION_INX+1
	SETB	GAME_FLAG, F_REDRAW_FIELD
	RTS
.endproc
ANIMATION_IDX_0: .BYTE TS_GAME_FIELD+$0, TS_GAME_FIELD+$4, TS_GAME_FIELD+$8, TS_GAME_FIELD+$C
ANIMATION_IDX_1: .BYTE TS_GAME_FIELD+$2, TS_GAME_FIELD+$6, TS_GAME_FIELD+$A, TS_GAME_FIELD+$E

.proc GAME_NEXT_FRAME
	JSR	PET_SCREEN_SHAKE
	JSR	BACKGROUND_TASKS
	WAIT_NMI
	RTS
.endproc

.proc GAME_NEXT_FRAME_FREEZED
	JSR	PET_SCREEN_SHAKE
	WAIT_NMI
	RTS
.endproc

.proc PET_SCREEN_SHAKE
; 	LDA	BG_TIMER
; 	CMP	#0
; 	BEQ	@PSS05
; 	RTS
; @PSS05:
	LDA	FLASH_TIMER
	BEQ	@PSS10		; FLASH_TIMER = 0?
	SET_GAME_BG_PALETTE  GAME_BG_PALETTE_RED
	JMP	@PSS20
@PSS10:	
 	SET_GAME_BG_PALETTE  GAME_BG_PALETTE_NORMAL
@PSS20:
 
 	LDA	SCREEN_SHAKE
	BEQ	@skip
	INC	SCREEN_SHAKE
@skip:	AND	#%00000111
	TAX
	LDA	SHAKE_TABLE_LOW,X
	STA	SCROLL_X
	RTS
.endproc

SHAKE_TABLE:
	.BYTE 4,2,0,2,4,6,8,6
SHAKE_TABLE_LOW:
	.BYTE 4,3,3,4,5,5,5,4
